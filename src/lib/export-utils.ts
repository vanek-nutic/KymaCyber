import { jsPDF } from 'jspdf';
import type { ToolCall } from '../types';

/**
 * Export utilities for downloading AI results in various formats
 */

/**
 * Download text content as a file
 */
export function downloadAsText(content: string, filename: string = 'kimi-cyber-result.txt') {
  const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Download markdown content as a file
 */
export function downloadAsMarkdown(content: string, filename: string = 'kimi-cyber-result.md') {
  const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Convert markdown content to formatted text for PDF
 */
function markdownToPlainText(markdown: string): string {
  // Remove markdown syntax while preserving structure
  let text = markdown;
  
  // Headers
  text = text.replace(/^#{1,6}\s+(.+)$/gm, (_, content) => content.toUpperCase() + '\n');
  
  // Bold
  text = text.replace(/\*\*(.+?)\*\*/g, '$1');
  
  // Italic
  text = text.replace(/\*(.+?)\*/g, '$1');
  
  // Code blocks
  text = text.replace(/```[\s\S]*?```/g, (match) => {
    return match.replace(/```\w*\n?/g, '').trim();
  });
  
  // Inline code
  text = text.replace(/`(.+?)`/g, '$1');
  
  // Links
  text = text.replace(/\[(.+?)\]\((.+?)\)/g, '$1 ($2)');
  
  // Lists
  text = text.replace(/^[\*\-]\s+/gm, 'â€¢ ');
  text = text.replace(/^\d+\.\s+/gm, '');
  
  return text;
}

/**
 * Download content as PDF with proper formatting (simple version - just final result)
 */
export function downloadAsPDF(
  content: string,
  query: string = '',
  filename: string = 'kimi-cyber-result.pdf'
) {
  const pdf = new jsPDF({
    orientation: 'portrait',
    unit: 'mm',
    format: 'a4'
  });

  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();
  const margin = 20;
  const maxWidth = pageWidth - (margin * 2);
  const lineHeight = 7;
  let yPosition = margin;

  // Add title
  pdf.setFontSize(16);
  pdf.setFont('helvetica', 'bold');
  pdf.text('Kimi Cyber - AI Analysis Report', margin, yPosition);
  yPosition += lineHeight * 1.5;

  // Add query if provided
  if (query) {
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'italic');
    const queryLines = pdf.splitTextToSize(`Query: ${query}`, maxWidth);
    pdf.text(queryLines, margin, yPosition);
    yPosition += (queryLines.length * lineHeight) + lineHeight;
  }

  // Add date
  pdf.setFontSize(9);
  pdf.setFont('helvetica', 'normal');
  pdf.text(`Generated: ${new Date().toLocaleString()}`, margin, yPosition);
  yPosition += lineHeight * 2;

  // Add separator line
  pdf.setDrawColor(0, 255, 136); // Neon green
  pdf.setLineWidth(0.5);
  pdf.line(margin, yPosition, pageWidth - margin, yPosition);
  yPosition += lineHeight;

  // Convert markdown to plain text
  const plainText = markdownToPlainText(content);

  // Add content
  pdf.setFontSize(10);
  pdf.setFont('helvetica', 'normal');
  
  const lines = plainText.split('\n');
  
  for (const line of lines) {
    // Check if we need a new page
    if (yPosition > pageHeight - margin) {
      pdf.addPage();
      yPosition = margin;
    }

    if (line.trim() === '') {
      yPosition += lineHeight * 0.5;
      continue;
    }

    // Split long lines
    const wrappedLines = pdf.splitTextToSize(line, maxWidth);
    
    for (const wrappedLine of wrappedLines) {
      if (yPosition > pageHeight - margin) {
        pdf.addPage();
        yPosition = margin;
      }
      
      pdf.text(wrappedLine, margin, yPosition);
      yPosition += lineHeight;
    }
  }

  // Add footer on last page
  const totalPages = pdf.getNumberOfPages();
  for (let i = 1; i <= totalPages; i++) {
    pdf.setPage(i);
    pdf.setFontSize(8);
    pdf.setTextColor(128, 128, 128);
    pdf.text(
      `Page ${i} of ${totalPages} | Generated by Kimi Cyber`,
      pageWidth / 2,
      pageHeight - 10,
      { align: 'center' }
    );
  }

  // Save the PDF
  pdf.save(filename);
}

/**
 * Download comprehensive PDF report including thinking, tool calls, and results
 */
export function downloadComprehensivePDF(
  query: string,
  thinking: string,
  toolCalls: ToolCall[],
  result: string,
  metrics: { thinkingTokens: number; toolCalls: number; elapsedTime: number },
  filename: string = 'kimi-cyber-comprehensive-report.pdf'
) {
  const pdf = new jsPDF({
    orientation: 'portrait',
    unit: 'mm',
    format: 'a4'
  });

  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();
  const margin = 20;
  const maxWidth = pageWidth - (margin * 2);
  const lineHeight = 6;
  let yPosition = margin;

  function addText(text: string, fontSize: number = 10, fontStyle: 'normal' | 'bold' | 'italic' = 'normal') {
    pdf.setFontSize(fontSize);
    pdf.setFont('helvetica', fontStyle);
    const lines = pdf.splitTextToSize(text, maxWidth);
    
    for (const line of lines) {
      if (yPosition > pageHeight - margin - 15) {
        pdf.addPage();
        yPosition = margin;
      }
      pdf.text(line, margin, yPosition);
      yPosition += lineHeight;
    }
  }

  function addSection(title: string) {
    if (yPosition > pageHeight - margin - 30) {
      pdf.addPage();
      yPosition = margin;
    }
    yPosition += lineHeight;
    pdf.setDrawColor(0, 255, 136);
    pdf.setLineWidth(0.5);
    pdf.line(margin, yPosition, pageWidth - margin, yPosition);
    yPosition += lineHeight;
    addText(title, 14, 'bold');
    yPosition += lineHeight * 0.5;
  }

  // Title Page
  pdf.setFontSize(20);
  pdf.setFont('helvetica', 'bold');
  pdf.text('Kimi Cyber', pageWidth / 2, yPosition, { align: 'center' });
  yPosition += lineHeight * 2;
  
  pdf.setFontSize(16);
  pdf.text('Comprehensive AI Analysis Report', pageWidth / 2, yPosition, { align: 'center' });
  yPosition += lineHeight * 4;

  // Query
  pdf.setFontSize(12);
  pdf.setFont('helvetica', 'bold');
  pdf.text('Research Query:', margin, yPosition);
  yPosition += lineHeight * 1.5;
  
  pdf.setFontSize(11);
  pdf.setFont('helvetica', 'italic');
  const queryLines = pdf.splitTextToSize(query, maxWidth);
  for (const line of queryLines) {
    pdf.text(line, margin, yPosition);
    yPosition += lineHeight;
  }
  yPosition += lineHeight * 2;

  // Metadata
  pdf.setFontSize(10);
  pdf.setFont('helvetica', 'normal');
  pdf.text(`Generated: ${new Date().toLocaleString()}`, margin, yPosition);
  yPosition += lineHeight;
  pdf.text(`Thinking Tokens: ${metrics.thinkingTokens}`, margin, yPosition);
  yPosition += lineHeight;
  pdf.text(`Tool Calls: ${metrics.toolCalls}`, margin, yPosition);
  yPosition += lineHeight;
  pdf.text(`Elapsed Time: ${metrics.elapsedTime}s`, margin, yPosition);
  yPosition += lineHeight * 3;

  // Table of Contents
  addSection('TABLE OF CONTENTS');
  addText('1. AI Thinking Process', 11, 'normal');
  addText('2. Tool Executions & Research Data', 11, 'normal');
  addText('3. Final Analysis & Conclusions', 11, 'normal');
  
  // New page for content
  pdf.addPage();
  yPosition = margin;

  // Section 1: Thinking Process
  addSection('1. AI THINKING PROCESS');
  if (thinking && thinking.trim()) {
    const thinkingText = markdownToPlainText(thinking);
    addText(thinkingText, 9, 'normal');
  } else {
    addText('No thinking process recorded.', 9, 'italic');
  }

  // Section 2: Tool Calls
  pdf.addPage();
  yPosition = margin;
  addSection('2. TOOL EXECUTIONS & RESEARCH DATA');
  
  if (toolCalls && toolCalls.length > 0) {
    toolCalls.forEach((tool, index) => {
      if (yPosition > pageHeight - margin - 40) {
        pdf.addPage();
        yPosition = margin;
      }
      
      // Tool header
      addText(`Tool ${index + 1}: ${tool.function.name}`, 11, 'bold');
      addText(`Status: ${tool.status || 'completed'}`, 9, 'normal');
      yPosition += lineHeight * 0.5;
      
      // Arguments
      if (tool.function.arguments) {
        addText('Arguments:', 10, 'bold');
        try {
          const args = typeof tool.function.arguments === 'string' 
            ? tool.function.arguments 
            : JSON.stringify(tool.function.arguments, null, 2);
          addText(args.substring(0, 500), 8, 'normal'); // Limit length
        } catch (e) {
          addText(String(tool.function.arguments).substring(0, 500), 8, 'normal');
        }
        yPosition += lineHeight * 0.5;
      }
      
      // Result
      if (tool.result) {
        addText('Result:', 10, 'bold');
        const resultText = String(tool.result).substring(0, 1000); // Limit length
        addText(resultText, 8, 'normal');
      }
      
      yPosition += lineHeight;
    });
  } else {
    addText('No tool executions recorded.', 9, 'italic');
  }

  // Section 3: Final Results
  pdf.addPage();
  yPosition = margin;
  addSection('3. FINAL ANALYSIS & CONCLUSIONS');
  
  if (result && result.trim()) {
    const resultText = markdownToPlainText(result);
    addText(resultText, 10, 'normal');
  } else {
    addText('No final results available.', 9, 'italic');
  }

  // Add footers to all pages
  const totalPages = pdf.getNumberOfPages();
  for (let i = 1; i <= totalPages; i++) {
    pdf.setPage(i);
    pdf.setFontSize(8);
    pdf.setTextColor(128, 128, 128);
    pdf.text(
      `Page ${i} of ${totalPages} | Generated by Kimi Cyber | ${new Date().toLocaleDateString()}`,
      pageWidth / 2,
      pageHeight - 10,
      { align: 'center' }
    );
  }

  // Save the PDF
  pdf.save(filename);
}

/**
 * Generate a filename with timestamp
 */
export function generateFilename(prefix: string = 'kimi-cyber', extension: string = 'txt'): string {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
  return `${prefix}-${timestamp}.${extension}`;
}

/**
 * Detect if content mentions generated files
 */
export function detectGeneratedFiles(content: string): string[] {
  const files: string[] = [];
  const patterns = [
    /(?:created|generated|produced|made)\s+(?:a\s+)?(.+?\.(?:pdf|docx|xlsx|csv|png|jpg|jpeg))/gi,
    /(?:PDF|Excel|CSV|Image|Document|Report|Chart)\s+(?:file|document|report)/gi,
    /\b\d+\s+pages?\b/gi
  ];

  for (const pattern of patterns) {
    const matches = content.match(pattern);
    if (matches) {
      files.push(...matches);
    }
  }

  return [...new Set(files)]; // Remove duplicates
}
